% Created 2024-12-01 Sun 12:21
% Intended LaTeX compiler: pdflatex
\documentclass{article}
\newcommand\foo{bar}


\usepackage{/home/jeszyman/repos/latex/sty/documentation}
\author{Jeffrey Szymanski}
\date{}
\title{Basecamp}
\begin{document}

\maketitle
\tableofcontents

\href{(run-latex-at-point)}{compile} using \href{basecamp.org}{\_run-latex-at-point}\_\\[0pt]
\vspace{5mm}
\hfill Last compiled \today.
% [[file:~/repos/latex/latex.org::#dd9bb77e-6ff7-44e0-9026-c371bdaf9603][Last compiled]]


\section{Setup and Configuration}
\label{sec:org779932b}
\subsection{General Information and Good Practice for Base Computing Setup}
\label{sec:orgb73ad3c}
\begin{enumerate}
\item Bash Configuration
\label{sec:org7bd5047}
\href{file:///home/jeszyman/.bashrc}{.bashrc} is used for interactive shell customizations and \href{file:///home/jeszyman/.profile}{.profile} is used for setting up environment variables and system-wide settings needed during the login process.\\[0pt]
\begin{enumerate}
\item Bashrc
\label{sec:orgb00e924}
\begin{itemize}
\item The default bashrc lives at \emph{etc/skel}.bashrc.\\[0pt]
\item Other programs such as singularity or conda may write directly to bashrc.\\[0pt]
\item Otherwise, bashrc is not altered automatically, as through Org-mode tangling. Instead, additional code is sourced though a simple if else statement. I source my basecamp shell libraries as follows:\\[0pt]

\begin{minted}[]{bash}

for file in "${HOME}"/repos/basecamp/lib/*.sh; do
    if [ -f "$file" ]; then
        source "$file"
    fi
done

\end{minted}

\item Use functions instead of aliases. Functions are more flexible, and can be debugged.\\[0pt]
\end{itemize}
\end{enumerate}
\end{enumerate}
\subsection{An opinionated and incomplete base computing configuration}
\label{sec:org993568e}
\begin{enumerate}
\item Base operating system
\label{sec:org075265b}

My base operating system is linux Ubuntu using a long-term support (LTS) version.\\[0pt]

\item Bash
\label{sec:orge8323f6}
\item Git repositories
\label{sec:org7acc91b}
Git repos live in \$\{HOME\}/repos.\\[0pt]

Git repos are modular using the git submodule structure.\\[0pt]

Git repos are pushed to GitHub.\\[0pt]

Git version control follows a simple trunk-based development strategy, with a single active branch: master. Major changes can be spun out into separate branches, but should be quickly merged back to master after changes are validated. Stable, validated versions are occasionally saved as git tags.\\[0pt]

\begin{enumerate}
\item Repositories where I am the main or sole author
\label{sec:orgb8c2b8c}

Repository code is tangled from a single Org-mode file. Updates from others are through pull requests as tangling would overwrite any direct commits.\\[0pt]
\end{enumerate}

\item Core directory structure
\label{sec:org949b346}
-- /\\[0pt]
\begin{center}
\begin{tabular}{}
\hline
\hline
\hline
\hline
\hline
\hline
\end{tabular}

\end{center}
\item Data governance
\label{sec:orgf2d2a93}
\begin{enumerate}
\item Security
\label{sec:orgecd36ce}
\item Architecture
\label{sec:org06a960e}
\item Lifecycle
\label{sec:org2501644}
\item Management
\label{sec:org81f983d}
\begin{enumerate}
\item Backup
\label{sec:org3d6aec2}
\end{enumerate}
\end{enumerate}
\item Core applications
\label{sec:org28a82c0}
core components (incomplete)\\[0pt]
\begin{itemize}
\item installed via apt\\[0pt]
\begin{itemize}
\item syncthing\\[0pt]
\item i3\\[0pt]
\item emacs\\[0pt]
\item texlive\\[0pt]
\item texlive\\[0pt]
\item rclone\\[0pt]
\item okular\\[0pt]
\item libreoffice\\[0pt]
\item minor\\[0pt]
\begin{itemize}
\item tree\\[0pt]
\end{itemize}
\end{itemize}
\item R\\[0pt]
\end{itemize}
\begin{enumerate}
\item R
\label{sec:org5d8e511}
\begin{itemize}
\item[{$\square$}] convert python and R to argparse \url{https://www.google.com/search?q=r+argparse+optparse\&oq=r+argparse+optparse\&gs\_lcrp=EgZjaHJvbWUyBggAEEUYOdIBCDg2MDFqMGo0qAIAsAIA\&sourceid=chrome-mobile\&ie=UTF-8}\\[0pt]
\end{itemize}
\item Python
\label{sec:orgb76031f}
\begin{itemize}
\item[{$\square$}] convert python and R to argparse \url{https://www.google.com/search?q=r+argparse+optparse\&oq=r+argparse+optparse\&gs\_lcrp=EgZjaHJvbWUyBggAEEUYOdIBCDg2MDFqMGo0qAIAsAIA\&sourceid=chrome-mobile\&ie=UTF-8}\\[0pt]
\end{itemize}

\item Emacs
\label{sec:orgf3f4226}
\begin{enumerate}
\item Initialization
\label{sec:org4f2217c}

When my Emacs loads, several configuration files and directories are references by symbolic link from git repositories to the default \textasciitilde{}/.emacs.d directory:\\[0pt]

\begin{itemize}
\item init.el\\[0pt]
\item public\_emacs\_config.el\\[0pt]
\item private\_emacs\_config.el\\[0pt]
\item public\_yasnippets\\[0pt]
\item private\_yasnippets\\[0pt]
\end{itemize}

These are loaded as optional files and if not found, they will throw a warning on initialization. These files are generated by Org-mode tangle.\\[0pt]

The init.el file is compiled from the Org-mode header a simple wrapper for other Elisp files.\\[0pt]

My public customized Emacs initialization is compiled from the Org-mode header \href{basecamp.org}{basecamp.org::Public configuration} and tangles to \href{config/public\_emacs\_config.el}{./config/public\_emacs\_config.el}.\\[0pt]

\begin{enumerate}
\item Style and good practice
\label{sec:org855e3f0}

Use-package is my preferred package management system. By default, use-package loads are structured as:\\[0pt]

(use-package package2\\[0pt]
  :ensure t\\[0pt]
  :init\\[0pt]
  :config\\[0pt]
)\\[0pt]

Each use-package keyword will expect a list or needs to be removed. Other keywords exist (see \href{https://www.gnu.org/software/emacs/manual/html\_node/use-package/index.html\#SEC\_Contents}{documentation}).\\[0pt]

\begin{itemize}
\item :ensure t will install any missing package\\[0pt]
\item :init is evaluated before package loading\\[0pt]
\item :config is evaluated after package loading\\[0pt]
\end{itemize}
\end{enumerate}

\item Org-mode
\label{sec:orge115506}
\begin{enumerate}
\item Policy, style, and good practice
\label{sec:org1978fde}
\begin{enumerate}
\item Block structures, source code, and tangling
\label{sec:orgafed3e7}

Lowercase is preferred for all block notation, \emph{e.g.}\\[0pt]

instead of\\[0pt]

At the file level, tangled code should reference it's location in orgmode files.\\[0pt]
tangle defaults to ./\\[0pt]
\end{enumerate}
\end{enumerate}
\item Templating with YASnippets
\label{sec:org1b5b55e}
My public YASnippets are compiled from source code blocks across my Org-mode agenda files. These tangle into appropriate subdirectories of \href{emacs/public\_yasnippets/}{./emacs/public\_yasnippets}. Private snippets are tangled into appropriate subdirectories of \href{file:///home/jeszyman/repos/org/emacs/private\_yasnippets}{org/emacs/private\_yasnippets}.\\[0pt]
\end{enumerate}
\end{enumerate}
\end{enumerate}
\section{Pan-computing Good Practive and General Style Guide}
\label{sec:org04e2924}
\begin{itemize}
\item Directory names should be in hyphen-case, using only lowercase letters (a-z), digits (0-9), and hyphens (-) as separators. Use as few words as possible\\[0pt]
\begin{itemize}
\item Can use more human-friendly title case and spaces with symlinks and shortcuts\\[0pt]
\end{itemize}
\item Prefer single-word file and directory names\\[0pt]
\item For multi-word file and directory names, prefer a dash (-) separator (\emph{e.g.} a-longer-file-name.txt)\\[0pt]
\end{itemize}
\section{Conda}
\label{sec:org8575cff}

For repositories and projects with heavy use of Python and R, software should be managed through the Conda package manager.\\[0pt]
\subsection{My Basecamp Conda Environment}
\label{sec:org5bfa2da}

A basecamp conda environment is stored in this repository at basecamp\_env.yaml.\\[0pt]
\section{Emacs}
\label{sec:org1803c1f}
\subsection{Setup, configuration, and customization}
\label{sec:orge874084}

My setup assumes normal emacs initialization and package structure at \textasciitilde{}/.emacs.d. The \textasciitilde{}/.emacs.d/init.el ensures package management and then conditionally loads other lisp files, if they exist, in the following order:\\[0pt]

\begin{enumerate}
\item \textasciitilde{}/.emacs.d/load-early.el\\[0pt]
\item \textasciitilde{}/.emacs.d/config/\\[0pt]
\item \textasciitilde{}/.emacs.d/load-late.el\\[0pt]
\end{enumerate}

The \textasciitilde{}/.emacs.d/config directory can contain symlinked lisp files from other locations. There is no assumed order within that directory.\\[0pt]

All files mentioned here can be found in the \hyperref[sec:orgab7a51c]{Lisp Files} appendix below.\\[0pt]

load-path is a list of directories that Emacs searches when you use functions like require, load, or when Emacs needs to find a library or package. When you add a directory to load-path, you're telling Emacs where to look for Emacs Lisp files when they need to be loaded. My load path is simply the default package location \textasciitilde{}/.emacs.d/elpa and also all files anywhere within \textasciitilde{}/.emacs.d/lisp\\[0pt]

\begin{itemize}
\item File backup\\[0pt]
\begin{itemize}
\item Local\\[0pt]
\begin{itemize}
\item Backup on save to \textasciitilde{}/.emacs.d/backup-save-list\\[0pt]
\item Emacs auto-saves on default settings to \textasciitilde{}/.emacs.d/auto-save-list \\[0pt]
\end{itemize}
\end{itemize}
\end{itemize}
\subsection{Simple Emacs Lisp Tutorial}
\label{sec:orgf67c5c8}
Alist\\[0pt]



alist: association list, stores key-value pairs\\[0pt]
\begin{minted}[]{common-lisp}
(setq my-alist '((key1 . value1)
                 (key2 . value2)
                 (key3 . value3)))

(assoc 'key2 my-alist)  ;; Returns (key2 . value2)
(cdr (assoc 'key2 my-alist))  ;; Returns value2

(setq my-alist (cons '(key4 . value5) my-alist))  ;; Adds (key4 . value4) to the front of the alist
(setq my-alist (assoc-delete-all 'key2 my-alist))  ;; Removes the element with key 'key2'

\end{minted}

\begin{minted}[]{common-lisp}
(setq my-alist '((key1 . value1)
                 (key2 . value2)
                 (key3 . value3)))

(prin1 (assoc 'key2 my-alist))  ;; Display (key2 . value2)
(princ "\n")  ;; Add a newline for readability
(prin1 (cdr (assoc 'key2 my-alist)))  ;; Display value2
(princ "\n")  ;; Add a newline for readability

(setq my-alist (cons '(key4 . value4) my-alist))  ;; Adds (key4 . value4) to the front of the alist
(prin1 my-alist)  ;; Display the updated alist
(princ "\n")  ;; Add a newline for readability

(setq my-alist (assoc-delete-all 'key2 my-alist))  ;; Removes the element with key 'key2'
(prin1 my-alist)  ;; Display the final alist
\end{minted}




progn: special form to evaluate sequence of expressions\\[0pt]
\begin{minted}[]{common-lisp}
(progn
  (message "First")
  (message "Second"))

\end{minted}
\subsection{Org-mode}
\label{sec:org341ab58}

If you place an asterisk at the beginning of your search, Org-mode will search only headlines (and not entry text). E.g., to find all entries with "emacs" in the headline, you could type:\\[0pt]

\begin{minted}[]{common-lisp}
C-c a s
[+-]Word/{Regexp} ...: *+emacs

\end{minted}
\subsection{Literate Programming with Emacs Org-mode}
\label{sec:orgeaa829d}

Generally comments should reside within the Org-mode structure and outside of code blocks. Tangling with a header argument :comments org will include both the header text and text between the header and code block. For example:\\[0pt]

(property drawers are excluded from tangling with custom-org-remove-properties-drawer)\\[0pt]
\begin{enumerate}
\item For example:
\label{sec:orgf582b06}
\begin{enumerate}
\item This header will be a comment
\label{sec:org7dc608f}
This text in org and below the header will be a comment\\[0pt]

\begin{minted}[]{bash}

# This text within the code block will be a comment

ls

\end{minted}

This comment will not appear in the tangled code\\[0pt]

\begin{enumerate}
\item Child headers are not comments unless they contain more code blocks
\label{sec:org8f7765a}
\end{enumerate}
\item Result:
\label{sec:orgcd9684c}

ls\\[0pt]
\end{enumerate}
\end{enumerate}

\subsection{YASnippets Style Guide and Good Practice}
\label{sec:org2fb40f6}
\begin{itemize}
\item \begin{itemize}
\item snippets are associated with a specific major mode, use of bash mode is discouraged\\[0pt]
\item As snippets are associated with major modes, single word keywords are encouraged (e.g. function instead of bash.function)\\[0pt]
\item snippets expand on tab\\[0pt]
\item for modes with extensive snippet libraries, prefixes followed by a single period are preferred (e.g. mod.meeting)\\[0pt]
\item prefixed snippets keywords are not likely to be confused with non-snippet terms, and they should expand without trigger\\[0pt]
\item Snippet creation and storage\\[0pt]
\begin{itemize}
\item Snippets are created in org mode bash source code blocks with formatting as in the snippet\\[0pt]
\begin{itemize}
\item Each snippet resides under it's own terminal org mode header. The header consists of only the snippet keyword and tags including the :yas: tag (i.e. * <SNIPPET KEYWORD> :yas: )\\[0pt]
\item The :yas: tag is reserved exclusively for yas block headers and does not have tag inheritance.\\[0pt]
\end{itemize}
\item Snippets are stored in the main org repository under the directory./snippets which is symlinked to .emacs.d. Snippets are therefore under org version control.\\[0pt]
\end{itemize}
\end{itemize}
\end{itemize}
\subsection{Notes}
\label{sec:orgf0b9c86}
See also Emacs and Org-mode use in my \LaTeX{} repository (\href{https://github.com/jeszyman/latex}{GitHub}, local buffer).\\[0pt]
\section{Appendices}
\label{sec:org0b721cb}
\subsection{Lisp Files}
\label{sec:orgab7a51c}
\begin{enumerate}
\item Initialization
\label{sec:org2d448dd}
\inputminted{emacs-lisp}{../emacs/init.el}
\item Load First
\label{sec:org5b97af1}
\inputminted{emacs-lisp}{../emacs/init.el}
\item Public configuration
\label{sec:org9113a15}
\inputminted{emacs-lisp}{../emacs/public_config.el}
\item Load Last
\label{sec:org7d8e5bf}
\inputminted{emacs-lisp}{../emacs/load-last.el}
\end{enumerate}
\end{document}
