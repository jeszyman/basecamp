---
- name: Common Public Playbook
  hosts: all
  gather_facts: true

  tasks:
    - name: Debug useful variable readouts
      debug:
        msg: "
          \n=== System Information ===\n\n
          Logged in as: {{ ansible_env.USER }}
          \n\nHome directory: {{ ansible_user_dir }}
          \n\nEnvironment HOME: {{ ansible_env.HOME }}
          \n\nPATH:
            {{ ansible_env.PATH }}
          \n\nOS: {{ ansible_distribution }} {{ ansible_distribution_version }} ({{ ansible_os_family }})
          \n\nHostname: {{ ansible_hostname }}
          \n\nFQDN: {{ ansible_fqdn }}
          \n\nDefault IPv4: {{ ansible_default_ipv4.address }}
          \n\nInventory Sources: {{ ansible_inventory_sources }}
          \n\nPackage Manager: {{ ansible_pkg_mgr }}
          \n========================="
    - name: Include config yaml
      include_vars:
        file: "{{ ansible_env.HOME }}/repos/basecamp/config/config.yaml"
    - name: Ensure directories are created without changing existing permissions
      file:
        path: "{{ item | expanduser }}"
        state: directory
      loop: "{{ directory_structure }}"
      vars:
        directory_structure: "{{ directory_structure | default([]) }}"
    - name: Ensure destination directory exists
      file:
        path: "{{ item.dest | dirname }}"
        state: directory
        mode: '0755'
      loop: "{{ wget_downloads }}"

    - name: Download file only if changed
      get_url:
        url: "{{ item.src }}"
        dest: "{{ item.dest }}"
        mode: '0644'
        force: no
        timeout: 30
        backup: yes  # Create backup if file changes
      loop: "{{ wget_downloads }}"
      retries: 3
      delay: 10
      register: download_results
      until: download_results is succeeded
      ignore_errors: yes
      tags: downloads

    - name: Report any download failures
      debug:
        msg: "WARNING: Failed to download {{ item.item.src }} - {{ item.msg }}"
      loop: "{{ download_results.results }}"
      when: item.failed
      tags: downloads
    - name: Check symlink sources
      ansible.builtin.stat:
        path: "{{ item.src }}"
      register: symlink_sources
      loop: "{{ public_symlinks }}"
      no_log: true

    - name: Output missing symlink sources
      debug:
        msg: "Missing source: {{ item.item.src }}"
      loop: "{{ symlink_sources.results | selectattr('stat.exists', 'equalto', false) | list }}"

    - name: Ensure parent directories of symlink destinations exist
      ansible.builtin.file:
        path: "{{ item.dest | dirname }}"
        state: directory
        mode: '0755'
      loop: "{{ public_symlinks }}"

    - name: Make public symlinks for existing sources
      ansible.builtin.file:
        src: "{{ item.item.src }}"
        dest: "{{ item.item.dest }}"
        state: link
        force: yes
        follow: false
      loop: "{{ symlink_sources.results }}"
      when: item.stat.exists
      no_log: true
    - name: Update apt cache
      apt:
        update_cache: yes
      become: true

    - name: Ensure APT packages are installed
      apt:
        name: "{{ item }}"
        state: latest
      become: true
      loop: "{{ apt_packages }}"
      register: apt_install_results
      ignore_errors: true  # Ensures playbook continues even if a package is missing
# Reset any stale NodeSource files (safe if absent)
    - name: Remove old NodeSource list and key
      become: true
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - /etc/apt/sources.list.d/nodesource.list
        - /usr/share/keyrings/nodesource.gpg
        - /usr/share/keyrings/nodesource.gpg.asc

    # Properly install the key: download, dearmor, permissions
    - name: Ensure keyring dir exists
      become: true
      ansible.builtin.file:
        path: /usr/share/keyrings
        state: directory
        mode: '0755'

    - name: Download NodeSource ASCII key
      become: true
      ansible.builtin.get_url:
        url: https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key
        dest: /usr/share/keyrings/nodesource.gpg.asc
        mode: '0644'
        force: yes

    - name: Dearmor NodeSource key to .gpg
      become: true
      ansible.builtin.command:
        cmd: gpg --dearmor -o /usr/share/keyrings/nodesource.gpg /usr/share/keyrings/nodesource.gpg.asc
      args:
        creates: /usr/share/keyrings/nodesource.gpg

    - name: Set key permissions
      become: true
      ansible.builtin.file:
        path: /usr/share/keyrings/nodesource.gpg
        mode: '0644'

    # Write the repo file explicitly (avoid apt_repository auto-update failures)
    - name: Add NodeSource repo (Node 20, using signed-by)
      become: true
      ansible.builtin.copy:
        dest: /etc/apt/sources.list.d/nodesource.list
        mode: '0644'
        content: |
          deb [signed-by=/usr/share/keyrings/nodesource.gpg] https://deb.nodesource.com/node_20.x nodistro main

    - name: apt update
      become: true
      ansible.builtin.apt:
        update_cache: yes

    - name: Ensure Node.js 20 is installed
      become: true
      ansible.builtin.apt:
        name: nodejs
        state: present

    - name: Ensure bash-language-server is installed globally
      become: true
      community.general.npm:
        name: bash-language-server
        global: true
        state: present
    - name: Download yq binary
      become: true
      ansible.builtin.get_url:
        url: https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
        dest: /usr/local/bin/yq
        mode: '0755'
        force: no

    - name: Verify yq installation
      become: true
      ansible.builtin.command: yq --version
      register: yq_version
      failed_when: "'version' not in yq_version.stdout.lower()"

    - name: Debug yq version
      ansible.builtin.debug:
        msg: "yq successfully installed: {{ yq_version.stdout }}"

    # Create a separate alias 'yqgo' for the Go version of yq so it can still be used
    # when the 'yq' command is shadowed by the Python version installed in a conda environment
    - name: Copy yq to yqgo for unambiguous use of Go version
      become: true
      ansible.builtin.copy:
        src: /usr/local/bin/yq
        dest: /usr/local/bin/yqgo
        remote_src: true
        mode: '0755'
    - name: Ensure fonts directory exists
      file:
        path: "{{ ansible_env.HOME }}/.local/share/fonts"
        state: directory
        mode: '0755'

    - name: Download and extract Nerd Fonts
      shell: |
        cd {{ ansible_env.HOME }}/.local/share/fonts
        curl -LO https://github.com/ryanoasis/nerd-fonts/releases/latest/download/FiraCode.zip
        unzip -o FiraCode.zip
        rm FiraCode.zip
      args:
        creates: "{{ ansible_env.HOME }}/.local/share/fonts/FiraCode-Regular.ttf"

    - name: Refresh font cache
      command: fc-cache -fv
    - name: Ensure ~/.bashrc.d exists
      ansible.builtin.file:
        path: "{{ ansible_env.HOME }}/.bashrc.d"
        state: directory
        mode: "0700"

    - name: Source ~/.bashrc.d/*.sh in .bashrc
      ansible.builtin.blockinfile:
        path: "{{ ansible_env.HOME }}/.bashrc"
        create: yes
        marker: "# {mark} BASHRC.D INCLUDE"
        block: |
          # Source all readable *.sh files from ~/.bashrc.d
          if [ -d "$HOME/.bashrc.d" ]; then
            for f in "$HOME/.bashrc.d"/*.sh; do
              [ -e "$f" ] || continue   # handles "no matches" without nullglob
              [ -r "$f" ] && [ -f "$f" ] && . "$f"
            done
          fi
    - name: Source all ~/.bashrc.d/*.sh files from .bashrc
      lineinfile:
        path: "{{ ansible_env.HOME }}/.bashrc"
        insertafter: EOF
        line: |
          if [ -d ~/.bashrc.d ]; then
            for f in ~/.bashrc.d/*.sh; do [ -r "$f" ] && . "$f"; done
          fi
        state: present
    - name: Ensure conda uses strict channel priority
      ansible.builtin.shell: |
        source ~/miniconda3/etc/profile.d/conda.sh && conda config --set channel_priority strict
      args:
        executable: /bin/bash
      environment:
        PATH: "{{ ansible_env.HOME }}/miniconda3/condabin:{{ ansible_env.PATH }}"
